# AUTOGENERATED! DO NOT EDIT! File to edit: ../15-activations.ipynb.

# %% auto 0
__all__ = [
    "set_seed",
    "Hook",
    "Hooks",
    "HooksCB",
    "append_stats",
    "get_stats_hist",
    "get_stats_hist_min",
    "ActivationStatsCB",
]

# %% ../15-activations.ipynb 1
import random
from functools import partial

import numpy as np

import torch

import miniai.datasets as ds
import miniai.learner as ln

import fastcore.all as fc

import matplotlib.pyplot as plt


# %% ../15-activations.ipynb 7
def set_seed(seed):
    """Set our system up to run in a deterministic matter"""
    torch.use_deterministic_algorithms(True)
    torch.manual_seed(seed)
    random.seed(seed)
    np.random.seed(seed)


# %% ../15-activations.ipynb 24
class Hook:
    """
    Registers a hook function on a model's forward pass.
    """

    def __init__(self, module, hook_fn):
        self.hook = module.register_forward_hook(partial(hook_fn, self))

    def remove(self):
        self.hook.remove()

    def __del__(self):
        self.remove()


# %% ../15-activations.ipynb 28
class Hooks(list):
    """Registers a hook function with a list of modules and manages their lifetime as a context manager."""

    def __init__(self, modules, hook_fn):
        super().__init__([Hook(module, hook_fn) for module in modules])

    def __enter__(self, *args):
        return self

    def __exit__(self, *args):
        self.remove()

    def __del__(self):
        self.remove()

    def __delitem__(self, idx):
        self[idx].remove()
        super().__delitem__(idx)

    def remove(self):
        for hook in self:
            hook.remove()


# %% ../15-activations.ipynb 31
class HooksCB(ln.Callback):
    def __init__(self, hook_fn, mod_filter=fc.noop, on_train=True, on_valid=False):
        fc.store_attr()
        super().__init__()

    def before_fit(self):
        mods = fc.filter_ex(self.learn.model.modules(), self.mod_filter)
        self.hooks = Hooks(mods, self._hook_fn)

    def after_fit(self):
        self.hooks.remove()

    def _hook_fn(self, *args, **kwargs):
        if (self.on_train and self.learn.model.training) or (self.on_valid and not self.learn.model.training):
            self.hook_fn(*args, *kwargs)

    def __iter__(self):
        return iter(self.hooks)

    def __len__(self):
        return len(self.hooks)


# %% ../15-activations.ipynb 34
def append_stats(hook, mod, inp, out):
    """Hook function to gets stats (mean, std dev, histogram of abs values) on fwd pass."""
    if not hasattr(hook, "stats"):
        hook.stats = ([], [], [])

    acts = ln.to_cpu(out)
    hook.stats[0].append(acts.mean())
    hook.stats[1].append(acts.std())
    hook.stats[2].append(acts.abs().histc(40, 0, 10))


# %% ../15-activations.ipynb 36
def get_stats_hist(stats_hook):
    """Get histogram in a suitable format for an image"""
    return torch.stack(stats_hook.stats[2]).t().float().log1p()


def get_stats_hist_min(stats_hook):
    """Get histogram in a suitable format for an image, looking at the smallest equally sized group."""
    hist = torch.stack(stats_hook.stats[2]).t().float()
    return hist[0] / hist.sum(0)


# %% ../15-activations.ipynb 40
class ActivationStatsCB(HooksCB):
    def __init__(self, mod_filter=fc.noop):
        super().__init__(append_stats, mod_filter)

    def plot_stats(self, figsize=(10, 4)):
        fig, axes = plt.subplots(1, 2, figsize=figsize)
        for hook in self:
            for stat_idx in [0, 1]:
                axes[stat_idx].plot(hook.stats[stat_idx])

        axes[0].set_title("Means")
        axes[1].set_title("Std devs")
        plt.legend(range(len(self)))

    def plot_hist(self, figsize=(11, 5)):
        fig, axes = ds.get_grid(len(self), figsize=figsize)
        for axis, hist in zip(axes.flatten(), self):
            ds.show_image(get_stats_hist(hist), axis, origin="lower")

    def plot_dead(self, figsize=(11, 5)):
        fig, axes = ds.get_grid(len(self), figsize=figsize)
        for axis, hist in zip(axes.flatten(), self):
            axis.plot(get_stats_hist_min(hist))
            axis.set_ylim(0, 1)
